//
// Multicore 2 / Multicore 2+
//
// Copyright (c) 2017-2020 - Victor Trucco
//
// All rights reserved
//
// Redistribution and use in source and synthezised forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// Redistributions in synthesized form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// Neither the name of the author nor the names of other contributors may
// be used to endorse or promote products derived from this software without
// specific prior written permission.
//
// THIS CODE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
// You are responsible for any legal issues arising from your use of this code.
//
///////////////////////////////////////////////////////////////////////////////
//
// Redistribution and use in source and synthezised forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice,
//   this list of conditions and the following disclaimer.
//
// * Redistributions in synthesized form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in the
//   documentation and/or other materials provided with the distribution.
//
// * Neither the name of the author nor the names of other contributors may
//   be used to endorse or promote products derived from this software without
//   specific prior written agreement from the author.
//
// * License is granted for non-commercial use only. A fee may not be charged
//   for redistributions as source code or in synthesized/hardware form without
//   specific prior written agreement from the author.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
///////////////////////////////////////////////////////////////////////////////

// PS/2 scancode to TK2000 matrix conversion


module keyboard #( 
    parameter integer clkfreq_g            // This is the system clock value in kHz
) (
    input wire clock_i,
    input wire reset_i,
    // PS/2 interface
    inout wire ps2_clk_io,
    inout wire ps2_data_io,
    // Row input
    input wire [7:0] rows_i,
    input wire row_ctrl_i,
    // Column output
    output wire [5:0] cols_o,
    output reg [12:1] FKeys_o,
    output reg [7:0] osd_o
);
`include "keyscans.vh" // Include the header file with scancode definitions

    // Interface to PS/2 block
    wire [7:0] keyb_data_s;
    wire keyb_valid_s;
    reg [7:0] osd_s; // Changed to reg since it's driven in an always block

    // Internal signals
    // In Verilog, a "type key_matrix_t is array (8 downto 0) of std_logic_vector(5 downto 0)"
    // is declared as an array of registers.
    reg [5:0] keys_s [8:0]; // Array of 6-bit registers, 9 elements (0 to 8)
    reg shift_s;
    reg release_s;
    reg extended_s;
    reg [5:0] k1_s, k2_s, k3_s, k4_s, k5_s, k6_s, k7_s, k8_s, k9_s;
    reg [7:0] idata_s;
    reg idata_rdy_s = 1'b0;

    assign osd_o = osd_s;

    // PS/2 interface instantiation (assuming ps2_iobase is a separate Verilog module)
    ps2_iobase #(
        .clkfreq_g(clkfreq_g)
    ) ps2 (
        .enable_i   (1'b1),
        .clock_i    (clock_i),
        .reset_i    (reset_i),
        .ps2_data_io(ps2_data_io),
        .ps2_clk_io (ps2_clk_io),
        .data_rdy_i (idata_rdy_s),
        .data_i     (idata_s),
        .send_rdy_o (), // Open/unconnected output
        .data_rdy_o (keyb_valid_s),
        .data_o     (keyb_data_s)
    );

    // Merging of rows (combinational logic)
    always @(*) begin
        k1_s = (rows_i[0] == 1'b1) ? keys_s[0] : 6'b0;
        k2_s = (rows_i[1] == 1'b1) ? keys_s[1] : 6'b0;
        k3_s = (rows_i[2] == 1'b1) ? keys_s[2] : 6'b0;
        k4_s = (rows_i[3] == 1'b1) ? keys_s[3] : 6'b0;
        k5_s = (rows_i[4] == 1'b1) ? keys_s[4] : 6'b0;
        k6_s = (rows_i[5] == 1'b1) ? keys_s[5] : 6'b0;
        k7_s = (rows_i[6] == 1'b1) ? keys_s[6] : 6'b0;
        k8_s = (rows_i[7] == 1'b1) ? keys_s[7] : 6'b0;
        k9_s = (row_ctrl_i == 1'b1) ? keys_s[8] : 6'b0;
    end

    assign cols_o = k1_s | k2_s | k3_s | k4_s | k5_s | k6_s | k7_s | k8_s | k9_s;

    // Main Keyboard Processing Logic
    always @(posedge clock_i or posedge reset_i) begin
        reg [1:0] keyb_valid_edge_v; // Declare as reg inside always block if it's a temp variable
        reg sendresp_v;              // Declare as reg inside always block if it's a temp variable

        if (reset_i == 1'b1) begin
            keyb_valid_edge_v <= 2'b00;
            release_s <= 1'b1;
            extended_s <= 1'b0;
            osd_s <= 8'hFF; // All ones for (others => '1')

            // Initialize all elements of the array
            for (integer i = 0; i <= 8; i = i + 1) begin
                keys_s[i] <= 6'b0; // (others => '0')
            end

            FKeys_o <= 12'b0; // (others => '0')

        end else begin
            keyb_valid_edge_v <= {keyb_valid_edge_v[0], keyb_valid_s}; // Shift register for edge detection
            if (keyb_valid_edge_v == 2'b01) begin // Detect rising edge of keyb_valid_s
                if (keyb_data_s == 8'hAA) begin
                    sendresp_v <= 1'b1;
                end else if (keyb_data_s == 8'hE0) begin
                    // Extended key code follows
                    extended_s <= 1'b1;
                end else if (keyb_data_s == 8'hF0) begin
                    // Release code follows
                    release_s <= 1'b0;
                end else begin
                    // Cancel extended/release flags for next time
                    release_s <= 1'b1;
                    extended_s <= 1'b0;
                    osd_s <= 8'hFF;

                    if (extended_s == 1'b0) begin // Normal scancodes
                        if (keyb_data_s == KEY_F12 && release_s == 1'b1) begin // This condition seems unusual; F12 pressed AND released in the same cycle?
                            osd_s[7:5] <= 3'b001; // OSD data pump command
                        end else begin
                            osd_s[7:5] <= 3'b111; // release
                        end

                        case (keyb_data_s)
                            KEY_LSHIFT: shift_s <= release_s; // Left shift
                            KEY_RSHIFT: shift_s <= release_s; // Right shift
                            default: ; // Do nothing for other keys
                        endcase

                        if (shift_s == 1'b0) begin // SHIFT not pressed
                            case (keyb_data_s)
                                KEY_B:         keys_s[0][1] <= release_s; // B
                                KEY_V:         keys_s[0][2] <= release_s; // V
                                KEY_C:         keys_s[0][3] <= release_s; // C
                                KEY_X:         keys_s[0][4] <= release_s; // X
                                KEY_Z:         keys_s[0][5] <= release_s; // Z

                                KEY_G:         keys_s[1][1] <= release_s; // G
                                KEY_F:         keys_s[1][2] <= release_s; // F
                                KEY_D:         keys_s[1][3] <= release_s; // D
                                KEY_S:         keys_s[1][4] <= release_s; // S
                                KEY_A:         keys_s[1][5] <= release_s; // A

                                KEY_SPACE:     keys_s[2][0] <= release_s; // SPACE
                                KEY_T:         keys_s[2][1] <= release_s; // T
                                KEY_R:         keys_s[2][2] <= release_s; // R
                                KEY_E:         keys_s[2][3] <= release_s; // E
                                KEY_W:         keys_s[2][4] <= release_s; // W
                                KEY_Q:         keys_s[2][5] <= release_s; // Q

                                KEY_BACKSPACE: keys_s[3][0] <= release_s; // Backspace (<-)
                                KEY_5:         keys_s[3][1] <= release_s; // 5 %
                                KEY_4:         keys_s[3][2] <= release_s; // 4 $
                                KEY_3:         keys_s[3][3] <= release_s; // 3 #
                                KEY_2:         keys_s[3][4] <= release_s; // 2 @
                                KEY_1:         keys_s[3][5] <= release_s; // 1 !

                                KEY_6:         keys_s[4][1] <= release_s; // 6 ¨
                                KEY_7:         keys_s[4][2] <= release_s; // 7 &
                                KEY_8:         keys_s[4][3] <= release_s; // 8 *
                                KEY_9:         keys_s[4][4] <= release_s; // 9 (
                                KEY_0:         keys_s[4][5] <= release_s; // 0 )

                                KEY_Y:         keys_s[5][1] <= release_s; // Y
                                KEY_U:         keys_s[5][2] <= release_s; // U
                                KEY_I:         keys_s[5][3] <= release_s; // I
                                KEY_O:         keys_s[5][4] <= release_s; // O
                                KEY_P:         keys_s[5][5] <= release_s; // P

                                KEY_H:         keys_s[6][1] <= release_s; // H
                                KEY_J:         keys_s[6][2] <= release_s; // J
                                KEY_K:         keys_s[6][3] <= release_s; // K
                                KEY_L:         keys_s[6][4] <= release_s; // L
                                KEY_TWOPOINT:  begin keys_s[6][5] <= release_s; keys_s[0][0] <= release_s; end // ; : (Invertido, setar SHIFT)

                                KEY_ENTER:     begin keys_s[7][0] <= release_s; osd_s[4] <= ~release_s; end // ENTER
                                KEY_N:         keys_s[7][1] <= release_s; // N
                                KEY_M:         keys_s[7][2] <= release_s; // M
                                KEY_COMMA:     keys_s[7][3] <= release_s; // ,
                                KEY_KPCOMMA:   keys_s[7][3] <= release_s; // ,
                                KEY_POINT:     keys_s[7][4] <= release_s; // .
                                KEY_KPPOINT:   keys_s[7][4] <= release_s; // .
                                KEY_SLASH:     begin keys_s[7][5] <= release_s; keys_s[0][0] <= release_s; end // / ? (Invertido, setar SHIFT)

                                KEY_KP0:       keys_s[4][5] <= release_s; // 0
                                KEY_KP1:       keys_s[3][5] <= release_s; // 1
                                KEY_KP2:       keys_s[3][4] <= release_s; // 2
                                KEY_KP3:       keys_s[3][3] <= release_s; // 3
                                KEY_KP4:       keys_s[3][2] <= release_s; // 4
                                KEY_KP5:       keys_s[3][1] <= release_s; // 5
                                KEY_KP6:       keys_s[4][1] <= release_s; // 6
                                KEY_KP7:       keys_s[4][2] <= release_s; // 7
                                KEY_KP8:       keys_s[4][3] <= release_s; // 8
                                KEY_KP9:       keys_s[4][4] <= release_s; // 9

                                KEY_LCTRL:     keys_s[8][0] <= release_s; // Left CTRL

                                // Other special keys sent as key combinations
                                KEY_MINUS:     begin keys_s[5][3] <= release_s; keys_s[0][0] <= release_s; end // - _ (SHIFT + I)
                                KEY_KPMINUS:   begin keys_s[5][3] <= release_s; keys_s[0][0] <= release_s; end // -   (SHIFT + I)
                                KEY_BL:        begin keys_s[4][2] <= release_s; keys_s[0][0] <= release_s; end // ' " (SHIFT + 7)
                                KEY_EQUAL:     begin keys_s[5][4] <= release_s; keys_s[0][0] <= release_s; end // = + (SHIFT + O)
                                KEY_KPASTER:   begin keys_s[4][5] <= release_s; keys_s[0][0] <= release_s; end // * (SHIFT + 0)
                                KEY_KPPLUS:    begin keys_s[5][5] <= release_s; keys_s[0][0] <= release_s; end // +   (SHIFT + P)

                                // Function Keys (for FPGA, not micro)
                                KEY_F1:        FKeys_o[1] <= release_s;
                                KEY_F2:        FKeys_o[2] <= release_s;
                                KEY_F3:        FKeys_o[3] <= release_s;
                                KEY_F4:        FKeys_o[4] <= release_s;
                                KEY_F5:        FKeys_o[5] <= release_s;
                                KEY_F6:        FKeys_o[6] <= release_s;
                                KEY_F7:        FKeys_o[7] <= release_s;
                                KEY_F8:        FKeys_o[8] <= release_s;
                                KEY_F9:        FKeys_o[9] <= release_s;
                                KEY_F10:       FKeys_o[10] <= release_s;
                                KEY_F11:       FKeys_o[11] <= release_s;
                                KEY_F12:       FKeys_o[12] <= release_s;

                                default: ; // Do nothing for unhandled scancodes
                            endcase

                        end else begin // SHIFT pressed
                            case (keyb_data_s)
                                KEY_B:         begin keys_s[0][1] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_V:         begin keys_s[0][2] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_C:         begin keys_s[0][3] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_X:         begin keys_s[0][4] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_Z:         begin keys_s[0][5] <= release_s; keys_s[0][0] <= release_s; end

                                KEY_G:         begin keys_s[1][1] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_F:         begin keys_s[1][2] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_D:         begin keys_s[1][3] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_S:         begin keys_s[1][4] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_A:         begin keys_s[1][5] <= release_s; keys_s[0][0] <= release_s; end

                                KEY_SPACE:     begin keys_s[2][0] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_T:         begin keys_s[2][1] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_R:         begin keys_s[2][2] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_E:         begin keys_s[2][3] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_W:         begin keys_s[2][4] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_Q:         begin keys_s[2][5] <= release_s; keys_s[0][0] <= release_s; end

                                KEY_BACKSPACE: begin keys_s[3][0] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_5:         begin keys_s[3][1] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_4:         begin keys_s[3][2] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_3:         begin keys_s[3][3] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_2:         begin keys_s[6][4] <= release_s; keys_s[0][0] <= release_s; end // 2 @ (SHIFT + L)
                                KEY_1:         begin keys_s[3][5] <= release_s; keys_s[0][0] <= release_s; end

                                // KEY_6:       -- Not existing as shifted char in VHDL comment
                                KEY_7:         begin keys_s[4][1] <= release_s; keys_s[0][0] <= release_s; end // 7 &  (SHIFT + 6)
                                KEY_8:         begin keys_s[4][5] <= release_s; keys_s[0][0] <= release_s; end // 8 * (SHIFT + 0)
                                KEY_9:         begin keys_s[4][3] <= release_s; keys_s[0][0] <= release_s; end // 9 (  (SHIFT + 8)
                                KEY_0:         begin keys_s[4][4] <= release_s; keys_s[0][0] <= release_s; end // 0 )  (SHIFT + 9)

                                KEY_Y:         begin keys_s[5][1] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_U:         begin keys_s[5][2] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_I:         begin keys_s[5][3] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_O:         begin keys_s[5][4] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_P:         begin keys_s[5][5] <= release_s; keys_s[0][0] <= release_s; end

                                KEY_H:         begin keys_s[6][1] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_J:         begin keys_s[6][2] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_K:         begin keys_s[6][3] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_L:         begin keys_s[6][4] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_TWOPOINT:  keys_s[6][5] <= release_s; // ; : (Invertido, nao setar SHIFT)

                                KEY_ENTER:     begin keys_s[7][0] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_N:         begin keys_s[7][1] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_M:         begin keys_s[7][2] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_COMMA:     begin keys_s[7][3] <= release_s; keys_s[0][0] <= release_s; end // , <
                                KEY_KPCOMMA:   keys_s[7][3] <= release_s; // ,
                                KEY_POINT:     begin keys_s[7][4] <= release_s; keys_s[0][0] <= release_s; end // . >
                                KEY_KPPOINT:   keys_s[7][4] <= release_s; // .
                                KEY_SLASH:     keys_s[7][5] <= release_s; // / ? (Invertido, nao setar SHIFT)

                                KEY_KP0:       keys_s[4][5] <= release_s; // 0
                                KEY_KP1:       keys_s[3][5] <= release_s; // 1
                                KEY_KP2:       keys_s[3][4] <= release_s; // 2
                                KEY_KP3:       keys_s[3][3] <= release_s; // 3
                                KEY_KP4:       keys_s[3][2] <= release_s; // 4
                                KEY_KP5:       keys_s[3][1] <= release_s; // 5
                                KEY_KP6:       keys_s[4][1] <= release_s; // 6
                                KEY_KP7:       keys_s[4][2] <= release_s; // 7
                                KEY_KP8:       keys_s[4][3] <= release_s; // 8
                                KEY_KP9:       keys_s[4][4] <= release_s; // 9

                                KEY_LCTRL:     begin keys_s[8][0] <= release_s; keys_s[0][0] <= release_s; end // Left CTRL

                                // Other special keys sent as key combinations
                                // KEY_MINUS: -- Not existing as shifted char in VHDL comment
                                KEY_KPMINUS:   begin keys_s[5][3] <= release_s; keys_s[0][0] <= release_s; end // - (SHIFT + I)
                                KEY_BL:        begin keys_s[3][4] <= release_s; keys_s[0][0] <= release_s; end // ' " (SHIFT + 2)
                                KEY_EQUAL:     begin keys_s[5][5] <= release_s; keys_s[0][0] <= release_s; end // = + (SHIFT + P)
                                KEY_KPASTER:   begin keys_s[4][5] <= release_s; keys_s[0][0] <= release_s; end // * (SHIFT + 0)
                                KEY_KPPLUS:    begin keys_s[5][5] <= release_s; keys_s[0][0] <= release_s; end // + (SHIFT + P)
                                KEY_TILDE:     begin keys_s[6][3] <= release_s; keys_s[0][0] <= release_s; end // ~ ^ (SHIFT + K)

                                default: ;
                            endcase
                        end // end if shift = 0

                    end else begin // Extended scancodes
                        if (shift_s == 1'b0) begin // Without shift
                            case (keyb_data_s)
                                KEY_KPENTER:   begin keys_s[7][0] <= release_s; osd_s[4] <= ~release_s; end // ENTER

                                // Cursor keys
                                KEY_LEFT:      begin keys_s[3][0] <= release_s; osd_s[2] <= ~release_s; end // Left
                                KEY_RIGHT:     begin keys_s[4][0] <= release_s; osd_s[3] <= ~release_s; end // Right
                                KEY_DOWN:      begin keys_s[5][0] <= release_s; osd_s[1] <= ~release_s; end // Down
                                KEY_UP:        begin keys_s[6][0] <= release_s; osd_s[0] <= ~release_s; end // Up
                                KEY_RCTRL:     keys_s[8][0] <= release_s; // Right CTRL

                                // Other special keys sent as key combinations
                                KEY_KPSLASH:   begin keys_s[7][5] <= release_s; keys_s[0][0] <= release_s; end // / (SHIFT + ?)

                                default: ;
                            endcase
                        end else begin // With shift
                            case (keyb_data_s)
                                KEY_KPENTER:   begin keys_s[7][0] <= release_s; keys_s[0][0] <= release_s; end // ENTER

                                // Cursor keys
                                KEY_LEFT:      begin keys_s[3][0] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_RIGHT:     begin keys_s[4][0] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_DOWN:      begin keys_s[5][0] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_UP:        begin keys_s[6][0] <= release_s; keys_s[0][0] <= release_s; end
                                KEY_RCTRL:     begin keys_s[8][0] <= release_s; keys_s[0][0] <= release_s; end

                                // Other special keys sent as key combinations
                                KEY_KPSLASH:   begin keys_s[7][5] <= release_s; keys_s[0][0] <= release_s; end

                                default: ;
                            endcase
                        end // end if shift
                    end // end if extended
                end // end if keyb_data_s == X"AA" / X"E0" / X"F0"
            end else begin // if not (keyb_valid_edge_v == 2'b01)
                if (sendresp_v == 1'b1) begin
                    sendresp_v <= 1'b0;
                    idata_s <= 8'h55;
                    idata_rdy_s <= 1'b1;
                end else begin
                    idata_rdy_s <= 1'b0;
                end
            end
        end // end if reset_i
    end // end always
endmodule
